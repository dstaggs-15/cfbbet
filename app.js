// ---- Config ----
const GAMES_URL = "public/games.json";   // generated by scripts/parse_games.py
const STORAGE_KEY = "cfb_picks_v1";
const GAMES_CACHE_KEY = "cfb_games_cache_v1";

// ---- State ----
let games = [];
let picks = loadPicks();
let chart;

// ---- Boot ----
document.addEventListener("DOMContentLoaded", async () => {
  games = await loadGames();
  renderGames(games);
  refreshStats();
  setupChart();

  document.getElementById("simulateBtn").addEventListener("click", simulateResults);
  document.getElementById("exportBtn").addEventListener("click", exportPicks);
  document.getElementById("importInput").addEventListener("change", importPicks);
});

// ---- Storage ----
function loadPicks() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) ?? []; }
  catch { return []; }
}
function savePicks() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(picks));
}

// Cache/fallback for games.json to support offline loads
async function loadGames() {
  try {
    const res = await fetch(`${GAMES_URL}?ts=${Date.now()}`);
    if (!res.ok) throw new Error("fetch failed");
    const data = await res.json();
    localStorage.setItem(GAMES_CACHE_KEY, JSON.stringify(data));
    return data;
  } catch {
    const cached = localStorage.getItem(GAMES_CACHE_KEY);
    if (cached) {
      return JSON.parse(cached);
    }
    return []; // last resort
  }
}

// ---- Rendering ----
function renderGames(games) {
  const root = document.getElementById("gameList");
  root.innerHTML = "";
  games.forEach((g, idx) => root.appendChild(gameCard(g, idx)));
}

function gameCard(g, idx) {
  const card = el("div", "card");

  const t1 = el("div", "team");
  t1.style.background = g.team1_colors.primary;
  t1.style.color = g.team1_colors.secondary;
  t1.append(el("div", "name", g.team1));
  t1.append(el("div", "line", `${g.spread_team1 > 0 ? "+" : ""}${g.spread_team1}`));

  const mid = el("div", "vs", "vs.");

  const t2 = el("div", "team");
  t2.style.background = g.team2_colors.primary;
  t2.style.color = g.team2_colors.secondary;
  t2.append(el("div", "name", g.team2));
  t2.append(el("div", "line", `${g.spread_team2 > 0 ? "+" : ""}${g.spread_team2}`));

  const controls = el("div", "controls");

  // pick controls
  const pickBtn1 = el("button", "pick-btn", g.team1);
  const pickBtn2 = el("button", "pick-btn", g.team2);
  const selectedBadge = el("span", "selected-badge");
  selectedBadge.style.display = "none";

  let choice = null;
  pickBtn1.addEventListener("click", () => {
    choice = "team1";
    pickBtn1.classList.add("selected");
    pickBtn2.classList.remove("selected");
    selectedBadge.textContent = `Selected: ${g.team1}`;
    selectedBadge.style.display = "inline-block";
  });
  pickBtn2.addEventListener("click", () => {
    choice = "team2";
    pickBtn2.classList.add("selected");
    pickBtn1.classList.remove("selected");
    selectedBadge.textContent = `Selected: ${g.team2}`;
    selectedBadge.style.display = "inline-block";
  });

  const amount = el("input", "amount");
  amount.placeholder = "$10";
  amount.type = "number";
  amount.min = "1";
  amount.step = "1";

  const lock = el("button", "lock-btn", "Lock");
  lock.addEventListener("click", () => {
    const amt = Math.max(1, Number(amount.value || 10));
    if (!choice) {
      alert("Pick a side first.");
      return;
    }
    const pick = {
      id: `${Date.now()}-${idx}`,
      when: new Date().toISOString(),
      teamPicked: choice === "team1" ? g.team1 : g.team2,
      team1: g.team1,
      team2: g.team2,
      side: choice, // "team1" | "team2"
      spreadPicked: choice === "team1" ? g.spread_team1 : g.spread_team2,
      overUnder: g.over_under,
      amount: amt,
      status: "pending", // "win" | "loss" | "push"
      profit: 0
    };
    picks.unshift(pick); // newest first
    savePicks();
    refreshStats();
  });

  // settle controls (input final score)
  const s1 = el("input", "score");
  s1.type = "number"; s1.placeholder = `${g.team1} pts`;
  const s2 = el("input", "score");
  s2.type = "number"; s2.placeholder = `${g.team2} pts`;
  const settle = el("button", "settle-btn", "Settle");

  settle.addEventListener("click", () => {
    const n1 = Number(s1.value);
    const n2 = Number(s2.value);
    if (!Number.isFinite(n1) || !Number.isFinite(n2)) {
      alert("Enter both final scores.");
      return;
    }
    settleGame(g, n1, n2);
  });

  const settleGroup = el("div", "settle-group");
  settleGroup.append(s1, s2, settle);

  controls.append(pickBtn1, pickBtn2, selectedBadge, amount, lock, settleGroup);

  card.append(t1, mid, t2, controls);
  return card;
}

// ---- Settle logic ----
// Determine ATS outcome for all pending picks matching this game
function settleGame(game, team1Score, team2Score) {
  // Resolve all pending picks that match these teams (in either order)
  let changed = false;
  picks = picks.map(pk => {
    const sameGame =
      ((pk.team1 === game.team1 && pk.team2 === game.team2) ||
       (pk.team1 === game.team2 && pk.team2 === game.team1));

    if (!sameGame || pk.status !== "pending") return pk;

    // normalize: what side did they pick?
    const pickedTeam1 = pk.teamPicked === game.team1;
    const spread = pk.spreadPicked; // spread for the chosen side at lock time

    // ATS: add the spread to the PICKED teamâ€™s score, compare to other score
    const pickedScore = pickedTeam1 ? team1Score : team2Score;
    const otherScore  = pickedTeam1 ? team2Score : team1Score;
    const adj = pickedScore + spread;

    if (adj > otherScore) {
      pk.status = "win";
      pk.profit = pk.amount; // even money for simplicity
    } else if (adj < otherScore) {
      pk.status = "loss";
      pk.profit = -pk.amount;
    } else {
      pk.status = "push";
      pk.profit = 0;
    }
    changed = true;
    return pk;
  });

  if (changed) {
    savePicks();
    refreshStats();
  } else {
    alert("No pending picks found for this matchup.");
  }
}

// ---- Stats, History, Chart ----
function refreshStats() {
  const w = picks.filter(p => p.status === "win").length;
  const l = picks.filter(p => p.status === "loss").length;
  const p = picks.filter(p => p.status === "push").length;
  document.getElementById("record").textContent = `${w}-${l}-${p}`;

  const net = picks.reduce((s, x) => s + (x.profit || 0), 0);
  document.getElementById("profit").textContent =
    (net >= 0 ? "+" : "") + `$${net.toFixed(2)}`;

  const body = document.getElementById("historyBody");
  body.innerHTML = "";
  picks.forEach(pk => {
    const tr = document.createElement("tr");
    const fmtDate = new Date(pk.when).toLocaleString();
    tr.append(
      td(fmtDate),
      td(`${pk.teamPicked}`),
      td(`$${pk.amount}`),
      td(pk.spreadPicked > 0 ? `+${pk.spreadPicked}` : `${pk.spreadPicked}`),
      td(pk.overUnder?.toFixed ? pk.overUnder.toFixed(1) : "-"),
      td(statusLabel(pk.status)),
      td((pk.profit >= 0 ? "+" : "") + `$${pk.profit.toFixed(2)}`)
    );
    body.appendChild(tr);
  });

  if (chart) {
    const labels = [];
    const data = [];
    let run = 0;
    const chronological = [...picks].reverse();
    chronological.forEach(pk => {
      run += (pk.profit || 0);
      labels.push(new Date(pk.when).toLocaleDateString());
      data.push(Number(run.toFixed(2)));
    });
    chart.data.labels = labels;
    chart.data.datasets[0].data = data;
    chart.update();
  }
}

function setupChart() {
  const ctx = document.getElementById("profitChart");
  chart = new Chart(ctx, {
    type: "line",
    data: {
      labels: [],
      datasets: [{
        label: "Net Profit ($)",
        data: [],
        borderWidth: 2,
        tension: 0.25
      }]
    },
    options: {
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { color: "#9aa0b4" }, grid: { display: false } },
        y: { ticks: { color: "#9aa0b4" }, grid: { color: "#262a40" } }
      }
    }
  });
}

// ---- Simulation (practice) ----
function simulateResults() {
  if (!picks.some(pk => pk.status === "pending")) {
    alert("No pending picks to settle.");
    return;
  }
  picks = picks.map(pk => {
    if (pk.status !== "pending") return pk;
    const covered = Math.random() < 0.5;
    if (covered) {
      pk.status = "win";
      pk.profit = pk.amount;
    } else {
      if (Math.random() < 0.05) {
        pk.status = "push";
        pk.profit = 0;
      } else {
        pk.status = "loss";
        pk.profit = -pk.amount;
      }
    }
    return pk;
  });
  savePicks();
  refreshStats();
}

// ---- Export / Import ----
function exportPicks() {
  const blob = new Blob([JSON.stringify(picks, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `picks-backup-${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function importPicks(ev) {
  const file = ev.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const arr = JSON.parse(reader.result);
      if (!Array.isArray(arr)) throw new Error("Invalid file");
      picks = arr;
      savePicks();
      refreshStats();
      alert("Import complete.");
    } catch {
      alert("Invalid JSON file.");
    }
  };
  reader.readAsText(file);
}

// ---- Helpers ----
function el(tag, cls, text) {
  const x = document.createElement(tag);
  if (cls) x.className = cls;
  if (text !== undefined) x.textContent = text;
  return x;
}
function td(text) { const x = document.createElement("td"); x.textContent = text; return x; }
function statusLabel(s) {
  if (s === "win") return "Win";
  if (s === "loss") return "Loss";
  if (s === "push") return "Push";
  return "Pending";
}
