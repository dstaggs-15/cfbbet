// ---- Config ----
const GAMES_URL = "public/games.json";   // generated by scripts/parse_games.py
const STORAGE_KEY = "cfb_picks_v1";
const GAMES_CACHE_KEY = "cfb_games_cache_v1";

console.log("app.js loaded");

// ---- State ----
let games = [];
let picks = loadPicks();
let chart;

// ---- Boot ----
document.addEventListener("DOMContentLoaded", async () => {
  setupHowToDropdown();

  games = await loadGames();
  console.log("Loaded games:", games.length);
  renderGames(games);
  refreshStats();
  setupChart();

  byId("simulateBtn").addEventListener("click", simulateResults);
  byId("exportBtn").addEventListener("click", exportPicks);
  byId("importInput").addEventListener("change", importPicks);
});

// ---- Storage ----
function loadPicks() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) ?? []; }
  catch { return []; }
}
function savePicks() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(picks));
}

// Cache/fallback for games.json to support offline loads
async function loadGames() {
  const errBox = byId("gamesError");
  try {
    const res = await fetch(`${GAMES_URL}?ts=${Date.now()}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error("Invalid games.json");
    localStorage.setItem(GAMES_CACHE_KEY, JSON.stringify(data));
    errBox.style.display = "none";
    return data;
  } catch (e) {
    const cached = localStorage.getItem(GAMES_CACHE_KEY);
    if (cached) {
      errBox.textContent = "Offline mode: using cached games.";
      errBox.style.display = "block";
      return JSON.parse(cached);
    }
    errBox.textContent = "Could not load games. Ensure public/games.json exists.";
    errBox.style.display = "block";
    return [];
  }
}

// ---- Rendering ----
function renderGames(games) {
  const root = byId("gameList");
  if (!root) {
    console.error("#gameList not found in DOM");
    return;
  }
  root.innerHTML = "";
  games.forEach((g, idx) => root.appendChild(gameCard(g, idx)));
}

function gameCard(g, idx) {
  const card = el("div", "card");

  const t1 = el("div", "team");
  t1.style.background = g.team1_colors?.primary || "#222";
  t1.style.color = g.team1_colors?.secondary || "#ddd";
  t1.append(el("div", "name", g.team1));
  t1.append(el("div", "line", `${g.spread_team1 > 0 ? "+" : ""}${g.spread_team1}`));

  const mid = el("div", "vs", "vs.");

  const t2 = el("div", "team");
  t2.style.background = g.team2_colors?.primary || "#444";
  t2.style.color = g.team2_colors?.secondary || "#ccc";
  t2.append(el("div", "name", g.team2));
  t2.append(el("div", "line", `${g.spread_team2 > 0 ? "+" : ""}${g.spread_team2}`));

  const controls = el("div", "controls");

  // pick controls
  const pickBtn1 = el("button", "pick-btn", g.team1);
  const pickBtn2 = el("button", "pick-btn", g.team2);
  const selectedBadge = el("span", "selected-badge");
  selectedBadge.style.display = "none";

  let choice = null;
  pickBtn1.addEventListener("click", () => {
    choice = "team1";
    pickBtn1.classList.add("selected");
    pickBtn2.classList.remove("selected");
    selectedBadge.textContent = `Selected: ${g.team1}`;
    selectedBadge.style.display = "inline-block";
  });
  pickBtn2.addEventListener("click", () => {
    choice = "team2";
    pickBtn2.classList.add("selected");
    pickBtn1.classList.remove("selected");
    selectedBadge.textContent = `Selected: ${g.team2}`;
    selectedBadge.style.display = "inline-block";
  });

  // Bet amount
  const amount = el("input", "amount");
  amount.placeholder = "$10";
  amount.type = "number"; amount.min = "1"; amount.step = "1";
  amount.inputMode = "numeric"; amount.pattern = "[0-9]*";

  const lock = el("button", "lock-btn", "Lock");
  lock.addEventListener("click", () => {
    const amt = Math.max(1, Number(amount.value || 10));
    if (!choice) return alert("Pick a side first.");
    const pick = {
      id: `${Date.now()}-${idx}`,
      when: new Date().toISOString(),
      teamPicked: choice === "team1" ? g.team1 : g.team2,
      team1: g.team1, team2: g.team2, side: choice,
      spreadPicked: choice === "team1" ? g.spread_team1 : g.spread_team2,
      overUnder: g.over_under, amount: amt, status: "pending", profit: 0
    };
    picks.unshift(pick);
    savePicks();
    refreshStats();
  });

  // settle controls (final score)
  const s1 = el("input", "score");
  s1.type = "number"; s1.placeholder = `${g.team1} pts`;
  s1.min = "0"; s1.step = "1"; s1.inputMode = "numeric"; s1.pattern = "[0-9]*";

  const s2 = el("input", "score");
  s2.type = "number"; s2.placeholder = `${g.team2} pts`;
  s2.min = "0"; s2.step = "1"; s2.inputMode = "numeric"; s2.pattern = "[0-9]*";

  const settle = el("button", "settle-btn", "Settle");
  settle.addEventListener("click", () => {
    const n1 = Number(s1.value), n2 = Number(s2.value);
    if (!Number.isFinite(n1) || !Number.isFinite(n2)) return alert("Enter both final scores.");
    settleGame(g, n1, n2);
  });

  const settleGroup = el("div", "settle-group");
  settleGroup.append(s1, s2, settle);

  controls.append(pickBtn1, pickBtn2, selectedBadge, amount, lock, settleGroup);

  card.append
