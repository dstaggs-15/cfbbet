// ---- Config ----
const GAMES_URL = "public/games.json";   // generated by scripts/parse_games.py
const STORAGE_KEY = "cfb_picks_v1";

// ---- State ----
let games = [];
let picks = loadPicks();
let chart;

// ---- Boot ----
document.addEventListener("DOMContentLoaded", async () => {
  games = await fetch(GAMES_URL).then(r => r.json());
  renderGames(games);
  refreshStats();
  setupChart();

  document.getElementById("simulateBtn").addEventListener("click", simulateResults);
});

// ---- Storage ----
function loadPicks() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) ?? []; }
  catch { return []; }
}
function savePicks() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(picks));
}

// ---- Rendering ----
function renderGames(games) {
  const root = document.getElementById("gameList");
  root.innerHTML = "";
  games.forEach((g, idx) => root.appendChild(gameCard(g, idx)));
}

function gameCard(g, idx) {
  const card = el("div", "card");

  const t1 = el("div", "team");
  t1.style.background = g.team1_colors.primary;
  t1.style.color = g.team1_colors.secondary;
  t1.append(el("div", "name", g.team1));
  t1.append(el("div", "line", `${g.spread_team1 > 0 ? "+" : ""}${g.spread_team1}`));

  const mid = el("div", "vs", "vs.");

  const t2 = el("div", "team");
  t2.style.background = g.team2_colors.primary;
  t2.style.color = g.team2_colors.secondary;
  t2.append(el("div", "name", g.team2));
  t2.append(el("div", "line", `${g.spread_team2 > 0 ? "+" : ""}${g.spread_team2}`));

  const controls = el("div", "controls");
  const pickBtn1 = el("button", "pick-btn", g.team1);
  const pickBtn2 = el("button", "pick-btn", g.team2);
  const amount = el("input", "amount");
  amount.placeholder = "$10";
  amount.type = "number";
  amount.min = "1";
  amount.step = "1";

  let choice = null;
  pickBtn1.addEventListener("click", () => {
    choice = "team1";
    pickBtn1.classList.add("selected");
    pickBtn2.classList.remove("selected");
  });
  pickBtn2.addEventListener("click", () => {
    choice = "team2";
    pickBtn2.classList.add("selected");
    pickBtn1.classList.remove("selected");
  });

  const lock = el("button", "lock-btn", "Lock");
  lock.addEventListener("click", () => {
    const amt = Math.max(1, Number(amount.value || 10));
    if (!choice) {
      alert("Pick a side first.");
      return;
    }
    const pick = {
      id: `${Date.now()}-${idx}`,
      when: new Date().toISOString(),
      teamPicked: choice === "team1" ? g.team1 : g.team2,
      team1: g.team1,
      team2: g.team2,
      spreadPicked: choice === "team1" ? g.spread_team1 : g.spread_team2,
      overUnder: g.over_under,
      amount: amt,
      status: "pending", // "win" | "loss" | "push"
      profit: 0
    };
    picks.unshift(pick); // newest first
    savePicks();
    refreshStats();
  });

  controls.append(pickBtn1, pickBtn2, amount, lock);

  card.append(t1, mid, t2, controls);
  return card;
}

// ---- Stats, History, Chart ----
function refreshStats() {
  // Record
  const w = picks.filter(p => p.status === "win").length;
  const l = picks.filter(p => p.status === "loss").length;
  const p = picks.filter(p => p.status === "push").length;
  document.getElementById("record").textContent = `${w}-${l}-${p}`;

  // Profit
  const net = picks.reduce((s, x) => s + (x.profit || 0), 0);
  document.getElementById("profit").textContent =
    (net >= 0 ? "+" : "") + `$${net.toFixed(2)}`;

  // History table
  const body = document.getElementById("historyBody");
  body.innerHTML = "";
  picks.forEach(pk => {
    const tr = document.createElement("tr");
    const fmtDate = new Date(pk.when).toLocaleString();
    tr.append(
      td(fmtDate),
      td(pk.teamPicked),
      td(`$${pk.amount}`),
      td(pk.spreadPicked > 0 ? `+${pk.spreadPicked}` : `${pk.spreadPicked}`),
      td(pk.overUnder?.toFixed ? pk.overUnder.toFixed(1) : "-"),
      td(statusLabel(pk.status)),
      td((pk.profit >= 0 ? "+" : "") + `$${pk.profit.toFixed(2)}`)
    );
    body.appendChild(tr);
  });

  // Profit over time (cumulative)
  if (chart) {
    const labels = [];
    const data = [];
    let run = 0;
    const chronological = [...picks].reverse(); // oldest to newest
    chronological.forEach(pk => {
      run += (pk.profit || 0);
      labels.push(new Date(pk.when).toLocaleDateString());
      data.push(Number(run.toFixed(2)));
    });
    chart.data.labels = labels;
    chart.data.datasets[0].data = data;
    chart.update();
  }
}

function setupChart() {
  const ctx = document.getElementById("profitChart");
  chart = new Chart(ctx, {
    type: "line",
    data: {
      labels: [],
      datasets: [{
        label: "Net Profit ($)",
        data: [],
        borderWidth: 2,
        tension: 0.25
      }]
    },
    options: {
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks: { color: "#9aa0b4" }, grid: { display: false } },
        y: { ticks: { color: "#9aa0b4" }, grid: { color: "#262a40" } }
      }
    }
  });
}

// ---- Simulation (practice) ----
// For each pending pick, randomly determine if their side covers the spread.
// Payout model here: even money (win = +bet, loss = -bet, push = 0).
function simulateResults() {
  if (!picks.some(pk => pk.status === "pending")) {
    alert("No pending picks to settle.");
    return;
  }
  picks = picks.map(pk => {
    if (pk.status !== "pending") return pk;
    // 50/50 for cover (practice mode only)
    const covered = Math.random() < 0.5; // heads covers, tails fails
    if (covered) {
      pk.status = "win";
      pk.profit = pk.amount; // +100 payout style
    } else {
      // 5% chance of push (for fun)
      if (Math.random() < 0.05) {
        pk.status = "push";
        pk.profit = 0;
      } else {
        pk.status = "loss";
        pk.profit = -pk.amount;
      }
    }
    return pk;
  });
  savePicks();
  refreshStats();
}

// ---- Helpers ----
function el(tag, cls, text) {
  const x = document.createElement(tag);
  if (cls) x.className = cls;
  if (text !== undefined) x.textContent = text;
  return x;
}
function td(text) { const x = document.createElement("td"); x.textContent = text; return x; }
function statusLabel(s) {
  if (s === "win") return "Win";
  if (s === "loss") return "Loss";
  if (s === "push") return "Push";
  return "Pending";
}
